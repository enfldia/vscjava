컬렉션 프레임워크
자바는 자료구조(Data Structure)를 바탕 객체들의 추가, 삭제, 검색할 수 있도록 관련된 인터페이스와 클래스들을 java.utill 패키지들의 총칭


컬렉션 프레임워크 인터페이스의 종류
List, Set, Map

collection 인터페이스
List와  Set 은 객체를 추가, 삭제, 검색하는 방법에 공점이 있기 때문에 공통된 메소드만 따로 모아 놓은 것.
collection 인터페이스 안에 List 인터페이스와 Set 인터페이스가 포함되어 있다.

각 인테페이스들의 특징

List
특징- 순서를 유지하고 저장, 중복 저장 가능
구현 클래스- ArrayList, Vector, LinkedList

Set
특징- 순서를 유지하지 않고 저장, 중복 저장 안됨
구현 클래스- HashSet, TreeSet

Map
특징- 키와 값으로 구성된 엔트리 저장, 키는 중복 저장 안됨
구현 클래스- HashMap, Hadhtable, TreeMap, Properties

----------------------------------------------------------------------------------------
List 컬렉션
객체를 인덱스로 관리하여 저장시 인덱스가 부여된다.
인덱스로 객체 검색,삭제하는 기능을 제공한다.

List 컬렉션에서 공통으로 사용하는 메소드
객체 추가       add(E e)                        주어진 객체를 맨 끝에 추가
                add(int index,E element)        주어진 인덱스에 객체를 추가
                set(int index,E element)        주어진 인덱스의 객체를 새로운 객체로 바꿈

객체 검색       contains(Object o)              주어진 객체가 저장되어 있는지 여부
                get(int index)                  주어진 인덱스에 저장된 객체를 리턴
                isEmpty()                       컬렉션이 비어 있는지 조사
                size()                          저장되어 있는 전체 객체 수를 리턴

객체 삭제       clear()                         저장된 모든 객체를 삭제
                remove(int index)               주어진 인덱스에 저장된 객체를 삭제
                remove(Object o)                주어진 객체를 삭제

----------------------------------------------------------------------------------------
ArrayList
List 컬렉션에서 가장 많이 사용되며,ArrayList에 객체를 추가하면 내부 배열에 객체가 저장된다.일반 배열과 차이점은 제한 없이 객체를 추가할 수 있다
List 컬렉션은 객체 자체를 저장하는게 아니라 객체의 번지를 저장한다.동일한 객체를 중복 저장 가능하다.null도 저장 가능.
객체를 추가하면 인덱스 0 부터 차례대로 저장된다.특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 인덱스가 1씩 당겨진다.
반대로 특정 인덱스로 삽입도 같다.따라서 빈번한 객체 삭제와 삽입이 일어나는 곳에 사용은 바람직하지 않다.-->(LinkedList가 적합함)

List<E> list = new ArrayList<E>();  파라미터E에 지정된 타입의 객체만 저장.
List<E> list = new ArrayList<>();   List의 객체와  ArrayList의 객체 타입이 같으면 생략 가능
List list= new ArryaList();         모든 타입의 객체 저장 가능

Vector
ArrayList와 동일한 내부 구조를 가지고 있지만 동기화된(synchronizde)메소드로 구성되어 멀티 스레드가 동시에 vector() 메소드를 실행할 수 없다.
그 결과 멀티 스레드 환경에서 안전하게 객체를 추가 또는 삭제할 수 있다.
반대로 ArrayList로 다중 스레드로 작업을 하면 두 스레드가 동시에 메소드를 호출할 수 있기 때문에 경합이 발생되어 하나만 저장되기 때문이다.

List<E> list = new Vector<E>();     지정 타입의 객체만 저장
List<E> list = new Vector<>();      타입이 같으면 생략 가능
List list = new Vertor();           모든 타입 객체 저장 가능

LinkedList
ArrayList와 사용 방법은 동일하지만 내부 구조는 완전히 다르다.인접 객체를 체인처럼 연결해서 관리한다.
그렇기에 특정 위치에서 객체를 삽입하거나 삭제하면 바로 앞뒤 링크만 변경하면 되므로 빈번한 객체 삭제와 삽입이 일어나느 곳에서 ArrayList보다 좋은 성능을 발휘한다.

List<E> list = new LinkedList<E>(); 지정 타입의 객체만 저장
List<E> list = new LinkedList<>();  타입이 같으면 생략 가능
List list = new LinkedList();       모든 타입 객체 저장 가능

----------------------------------------------------------------------------------------
Set 컬렉션
저장 순서가 유지되지 않는다.객체를 중복 저장할 수 없으며 null도 하나만 저장이 가능하다. 순서와 상관 없이 중복이 허용되지 않기 때문에 수학의 집하에 비유된다.
저장될 때와 찾을 때 순서가 다를 수 있다.
인덱스로 관리하지 않기 때문에 인덱스를 매개값으로 갖는 메소드가 없다.

Set 컬렉션에서 고통으로 사용하는 메소드()

객체 추가-  boolean add(E e)            주어진 객체를 성공적으로 저장하면 true를 리턴하고 중복 객체면 false를 리턴

객체 검색   boolean contains(Object o)  주어진 객체가 저장되어 있는지 여부
            isEmpty()                   컬렉션이 비어 있는지 조사
            iterator<E> iterator()      저장된 객체를 한 번씩 가져오는 반복자 리턴
            int size()                  저장되어 있는 전체 객체 수 리턴

객체 삭제   void clear()                저장된 모든 객체를 삭제
            boolean remove(Objet o)     주어진 객체를 삭제
----------------------------------------------------------------------------------------
HashSet
Set 컬렉션 중에서 가장 많이 사용된다.동일한 객체는 중복 저장하지 않는다.여기서 동일한 객체란 동등한 객체를 말한다.
HashSet은 다른 객체라도 hashCode() 메소드의 리턴값이 같고, equals() 메소드가 ture를 리턴하면 동일한 객체라 판단하고 중복 저장하지 않는다.


